import numpy as np
import sys

#from pyppeteer import launch



'''
input_line= '2\t1\t2\t0\n'
print(input_line.rstrip('\n').split('\t'))
print(np.array(list(map(int, input_line.rstrip('\n').split('\t')))))
board[0]=np.array(list(map(int, input_line.rstrip('\n').split('\t'))))
print(board)

'''
'''
print(input_line.strip().split('\t'))
print(np.array(list(map(int, input_line.strip().split('\t')))))

values = np.array(list(map(int, input_line.strip().split('\t'))))

print(np.where(values==2, None, values))

#$ python takuzu.py < Exemplo1.txt



array = np.array([[1,2,3], [1,2,3], [1,1,9]])

_, row_counts = np.unique(array, axis=0, return_counts=True)
print(row_counts)



oi = np.array([(0,2),(3,4)])


b = np.array(list(zip((oi==0).sum(axis=0), (oi==0).sum(axis=1))))
print(b)

linha_01 = np.array([(self.board[row, :] == 0).sum(axis=1),(self.board[row, :] == 1).sum(axis=1)])
        coluna_01 = np.array([(self.board[:,col] == 0).sum(axis=0),(self.board[:,col] == 1).sum(axis=0)])

        if self.board_size % 2:
            menor_linhas = linha_01 < self.board_size//2
            menor_colunas = coluna_01 < self.board_size//2
            if np.all(menor_linhas) and np.all(menor_colunas):
                self.actions=np.array([])
            elif not menor_linhas[0]:
                np.delete(self.actions, where= self.actions[row,:,0])

board = Board.parse_instance_from_stdin()

problem = Takuzu(board)

s0 = TakuzuState(board)
print(s0.board)

s1 = problem.result(s0,(0,0,1))
print(s0.board)
print(s1.board)
s2 = problem.result(s1,(0,1,0))
print(s0.board)
print(s1.board)
print(s2.board)


a = np.array([[1,2,1],[1,4,0]])
print(a)
result = str(a.ravel())
#print(hash(result))

#result = np.where(a[0] == 1)


#print(result)

b = a.copy()

print(b is a)

b[0,0]=99

print(b, '=b')
print(a, '=a')



a=0
b=1
c=0
d=1
print((a==0 or b==0) and c==0)
'''

"""
for col in range(board_size):
            if 2 not in board_np[:, col]: #coluna completa

                #teste à adjacência na coluna
                for i in range(board_size):
                    if board.adjacent_vertical_numbers(i,col).count(board.get_number(i,col))==2 or board.adjacent_horizontal_numbers(i,col).count(board.get_number(i,col))==2:
                        broken_rule += 100

                #se encontrar alguma coluna igual
                if np.any(board_np[:, indices != col] == board_np[:, col]): #também podiamos fazer a comparação para colunas que já estão completas mas idk
                    broken_rule += 100
"""
"""
if last_action != None and parent_node != None:
          parent_state = parent_node.state
          lin_changed = last_action[0]
          col_changed = last_action[1]
          val_inserted = last_action[2]

#se ainda tivermos muita falta de 1's, jogar um 1 pode ser mais relavente (mandei o valor de ainda nos faltar mais de 40% (mais ou menos, depende se estamos a falar de impar ou par) para termos o nr de 1s final)
          if np.count_nonzero(parent_state.board.board[lin_changed, :] == 1) < 0.6*(board_size//2): 
              if val_inserted == 1:
                  f += 0
              elif val_inserted == 0:
                  f += 1

          elif np.count_nonzero(parent_state.board.board[:, col_changed] == 1) < 0.6*(board_size//2): 
              if val_inserted == 1:
                  f += 0
              elif val_inserted == 0:
                  f += 1

    def empty_positions(self):
        result = np.where(self.board.board == 2)
        empty = list(zip(result[0],result[1]))
        return empty
"""
'''
a = np.array([[1,2,1],[1,4,1], [1,2,1]])
indices = np.arange(3)
###print(np.where(a == 2))

for i in a:
    print(i)
'''
a='lau'
print(hash(a))

b='lau'
print(hash(b))

print(a==b)

c=np.array([1,2,3])
d=np.array([4,5,6])
cs = np.column_stack((c,d))
cs_zip = list(zip(c,d))
print(cs)
print(list(zip(c,d)))
print(cs[0][1])
#print(list(zip(c,d)))
